#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_dataset.ipynb (unless otherwise specified).

__all__ = ['read_jsonl', 'base64ToImage', 'get_bbox_coordinates', 'get_bbox_from_spans', 'ProdigyDataReader', 'LABELS']

#Cell
import json
import nbdev
import re
import base64
import PIL
import pathlib
import torch
import jsonlines
from torch.utils.data import Dataset, DataLoader
from io import BytesIO
from fastai.vision import *

#Cell
def read_jsonl(file_path):
    """Read a .jsonl file and yield its contents line by line.
    file_path (unicode / Path): The file path.
    YIELDS: The loaded JSON contents of each line.
    """
    with pathlib.Path(file_path).open('r', encoding='utf8') as f:
        for line in f:
            try:  # hack to handle broken jsonl
                str_json = json.loads(line)
                if str_json['answer'] == 'accept':
                    yield str_json
            except ValueError:
                continue

#Cell
def base64ToImage(base64_string):
    """ convert base64 string to image"""
    base64_string = base64_string[23:]
    imgdata = base64.b64decode(str(base64_string))
    image = PIL.Image.open(io.BytesIO(imgdata))
    image = Image(torch.from_numpy(np.rollaxis(np.array(image), 2, 0)))
    return image

#Cell
def get_bbox_coordinates(points:list):
    """converts points from json file to fastai boxes points"""
    y1, x1 = points[0]
    y2, x2 = points[2]

    return [x1, y1, x2, y2]

#Cell
def get_bbox_from_spans(height, width, spans):
    """gets fastai bbox object from spans entry"""
    if len(spans) == 0:
        return

    points = []
    labels = []
    for span in spans:
        coordinates = get_bbox_coordinates(span['points'])
        points.append(coordinates)
        labels.append(span['label'])


    bbox = ImageBBox.create(*image.size, bboxes= points, labels=list(range(len(labels))), classes=labels)
    return bbox


#Cell
LABELS = ['FABI', 'FABI_POO', 'FABI_PISS', 'SOPHIE', 'HUMAN']


class ProdigyDataReader(Dataset):
    """
    ProdigyDataReader
    """
    def __init__(self, root='test_data/sample.jsonl', transforms=None, object_categories=LABELS):
        self.root = pathlib.Path(root)
        self.transforms = transforms
        self.class_names = object_categories
        self.num_classes = len(object_categories)

        self.images = [image for image in self.read_jsonl(str(self.root))]


    def __getitem__(self, idx):
        """ get item of the index.
        In this particular case it is important to understand that the x-axis
        represents the width and the y-axis the height.
        """
        item = self.images[idx]

        img = self.stringToRGB(item['image'])

        boxes = []
        labels = []
        for element in item.get('spans', []):
            points = np.array(element['points']).round().astype(int)
            xmin = np.min(points[:, 0])
            ymin = np.min(points[:, 1])
            xmax = np.max(points[:, 0])
            ymax = np.max(points[:, 1])
            boxes.append([xmin, ymin, xmax, ymax])

            label = self.class_names.index(element['label'])
            labels.append(label)

        boxes = torch.as_tensor(boxes, dtype=torch.float32)
        labels = torch.as_tensor(labels, dtype=torch.int64)

        image_id = torch.as_tensor([idx])
        # suppose all instances are not crowd
        iscrowd = torch.zeros((len(boxes), ), dtype=torch.int64)

        target = {}
        target["boxes"] = boxes
        target["labels"] = labels
        target["image_id"] = image_id

        #if self.transforms is not None:
        #    img, target = self.transforms(img, target)
        return img, target

    def __len__(self):
        return len(self.images)